/**
 * SecurityVulnerability model with CVE validation
 * Represents a known security issue in a dependency
 */

export interface SecurityAuditResult {
  vulnerabilityCount: {
    low: number
    moderate: number
    high: number
    critical: number
  }
  vulnerabilities: SecurityVulnerability[]
  timestamp: Date
}

// Security vulnerability resolution types
export interface VulnerabilityResolutionResult {
  totalVulnerabilities: number
  resolvedCount: number
  failedCount: number
  resolutions: VulnerabilityResolution[]
  timestamp: Date
}

export interface VulnerabilityResolution {
  vulnerabilityId: string
  strategy: 'patch' | 'update' | 'manual' | 'failed'
  success: boolean
  appliedFix: AppliedFix | null
  error: string | null
}

export interface AppliedFix {
  type: 'audit-fix' | 'package-update' | 'version-update'
  packageName: string
  fromVersion: string
  toVersion: string
  command: string
}

export interface FixResult {
  success: boolean
  fix: AppliedFix | null
  error: string | null
}

export interface UpdateResult {
  success: boolean
  command: string
  error: string | null
}

export type SeverityLevel = 'low' | 'moderate' | 'high' | 'critical'
export type VulnerabilitySource = 'npm' | 'github' | 'snyk' | 'nvd'

export interface SecurityVulnerabilityData {
  id: string
  severity: SeverityLevel
  affectedVersions: string
  description: string
  source: VulnerabilitySource
  publishedDate: Date
  fixAvailable: boolean
  patchedVersion?: string
  patchedVersions?: string[]
  packageName?: string
  installedVersion?: string
}

export class SecurityVulnerability {
  public id: string
  public severity: SeverityLevel
  public affectedVersions: string
  public patchedVersion?: string
  public patchedVersions?: string[]
  public packageName?: string
  public installedVersion?: string
  public description: string
  public source: VulnerabilitySource
  public publishedDate: Date
  public fixAvailable: boolean

  constructor(data: SecurityVulnerabilityData) {
    this.validateId(data.id)
    this.validateSeverity(data.severity)
    this.validateSource(data.source)
    this.validateDescription(data.description)
    this.validatePublishedDate(data.publishedDate)

    this.id = data.id
    this.severity = data.severity
    this.affectedVersions = data.affectedVersions
    this.description = data.description
    this.source = data.source
    this.publishedDate = data.publishedDate
    this.fixAvailable = data.fixAvailable
    this.patchedVersion = data.patchedVersion
    this.patchedVersions = data.patchedVersions
    this.packageName = data.packageName
    this.installedVersion = data.installedVersion

    if (data.patchedVersion) {
      this.validatePatchedVersion(data.patchedVersion)
    }
  }

  private validateId(id: string): void {
    if (!id || typeof id !== 'string') {
      throw new Error('Vulnerability ID is required and must be a string')
    }

    // CVE format: CVE-YYYY-NNNN+ or GHSA format: GHSA-xxxx-xxxx-xxxx
    const cvePattern = /^CVE-\d{4}-\d{4,}$/
    const ghsaPattern = /^GHSA-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}$/

    if (!cvePattern.test(id) && !ghsaPattern.test(id)) {
      throw new Error(`Invalid vulnerability ID format: ${id}. Must be CVE-YYYY-NNNN or GHSA-xxxx-xxxx-xxxx format`)
    }
  }

  private validateSeverity(severity: SeverityLevel): void {
    const validSeverities: SeverityLevel[] = ['low', 'moderate', 'high', 'critical']
    if (!validSeverities.includes(severity)) {
      throw new Error(`Invalid severity level: ${severity}. Must be one of: ${validSeverities.join(', ')}`)
    }
  }

  private validateSource(source: VulnerabilitySource): void {
    const validSources: VulnerabilitySource[] = ['npm', 'github', 'snyk', 'nvd']
    if (!validSources.includes(source)) {
      throw new Error(`Invalid vulnerability source: ${source}. Must be one of: ${validSources.join(', ')}`)
    }
  }

  private validateDescription(description: string): void {
    if (!description || typeof description !== 'string' || description.trim().length === 0) {
      throw new Error('Vulnerability description is required and must be a non-empty string')
    }
  }

  private validatePublishedDate(date: Date): void {
    if (!(date instanceof Date) || isNaN(date.getTime())) {
      throw new Error('Published date must be a valid Date object')
    }

    // Check if date is in the future (with 1 day tolerance for timezone issues)
    const now = new Date()
    const maxFutureDate = new Date(now.getTime() + 24 * 60 * 60 * 1000)
    
    if (date > maxFutureDate) {
      throw new Error('Published date cannot be in the future')
    }
  }

  private validatePatchedVersion(version: string): void {
    if (!version || typeof version !== 'string') {
      throw new Error('Patched version must be a string')
    }

    // Basic semver pattern validation
    const semverPattern = /^\d+\.\d+\.\d+([+-].*)?$/
    if (!semverPattern.test(version)) {
      throw new Error(`Invalid patched version format: ${version}. Must follow semver format`)
    }
  }

  public getSeverityScore(): number {
    const scores = {
      low: 1,
      moderate: 2,
      high: 3,
      critical: 4
    }
    return scores[this.severity]
  }

  public isMoreSevereThan(other: SecurityVulnerability): boolean {
    return this.getSeverityScore() > other.getSeverityScore()
  }

  public isFixable(): boolean {
    return this.fixAvailable
  }

  public hasPatch(): boolean {
    return this.fixAvailable && Boolean(this.patchedVersion)
  }

  public isPublishedAfter(date: Date): boolean {
    return this.publishedDate > date
  }

  public isPublishedBefore(date: Date): boolean {
    return this.publishedDate < date
  }

  public toJSON(): any {
    return {
      id: this.id,
      severity: this.severity,
      affectedVersions: this.affectedVersions,
      patchedVersion: this.patchedVersion,
      description: this.description,
      source: this.source,
      publishedDate: this.publishedDate.toISOString(),
      fixAvailable: this.fixAvailable
    }
  }

  public static fromJSON(data: any): SecurityVulnerability {
    return new SecurityVulnerability({
      id: data.id,
      severity: data.severity,
      affectedVersions: data.affectedVersions,
      patchedVersion: data.patchedVersion,
      description: data.description,
      source: data.source,
      publishedDate: new Date(data.publishedDate),
      fixAvailable: data.fixAvailable
    })
  }
}